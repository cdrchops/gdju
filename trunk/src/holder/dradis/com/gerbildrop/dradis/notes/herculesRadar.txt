    private final static Color BACK_COLOR = new Color(20, 90, 20);
    private final static Color BASE_COLOR = new Color(60, 160, 60);
    private final static Color POINT_COLOR = new Color(20, 230, 20);
    private final static Color HEADING_COLOR = new Color(150, 230, 150);
    private final static Color DARK_BORDER_COLOR = new Color(60, 100, 60);
    private final static Color BRIGHT_BORDER_COLOR = new Color(120, 200, 120);
    private final static Color HELPER_COLOR = new Color(160, 180, 160);

    private final Vector3f mOrigin = new Vector3f();
    private final Vector3f mDirection = new Vector3f();
    private Vector3f[] mContacts = new Vector3f[0];

    private float mRange = 500;
    private int mMaxLog = 4;
    private final Font mFont = new Font("Verdana", Font.PLAIN, 8);
    private final static String[] mRangeDecals = {"10", "100", "1000", "10000"};
    private final static double LOG10 = Math.log(10.0);
    private static final Dimension PREFERRED_SIZE = new Dimension(128, 128);

    private static void drawCircle(Graphics2D g, int x, int y, int radius, int startAngle, int arcAngle) {
        g.drawArc(x - radius, y - radius, radius << 1, radius << 1, startAngle, arcAngle);
    }

    public void paintComponent(Graphics graphics) {
//        super.paintComponent(graphics);

        Rectangle bds = null;//this.getBounds();
        Graphics2D g = (Graphics2D) graphics;


        int diameter = (bds.width > bds.height ? bds.height : bds.width) - 6;
        int radius = diameter >> 1;
        int centerX = bds.width >> 1;
        int centerY = bds.height >> 1;
        int bdsX = centerX - radius;
        int bdsY = centerY - radius;

        g.setPaint(BASE_COLOR);
        g.fillOval(bdsX, bdsY, diameter, diameter);

        //
        // the circles stuff looks better when antialiased
        //
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        g.setPaint(DARK_BORDER_COLOR);
        g.drawArc(bdsX, bdsY, diameter, diameter, 45 + 180, 180);

        g.setPaint(BRIGHT_BORDER_COLOR);
        g.drawArc(bdsX, bdsY, diameter, diameter, 45, 180);

        //
        // draw the range helpers
        //
        g.setPaint(Color.DARK_GRAY);
        g.setFont(mFont);
        int helperincr = radius / (mMaxLog - 1);
        int helperradius = helperincr;
        for (int i = 1; i < mMaxLog - 1; i++) {
            int opening = 50 - i * 10;
            drawCircle(g, centerX, centerY, helperradius, 90, 360 - opening);
            g.drawString(mRangeDecals[i], centerX, centerY - helperradius + 4);
            helperradius += helperincr;
        }

        //
        // Heading indicator
        //
        g.setPaint(HEADING_COLOR);
        g.drawLine(centerX, centerY, centerX + (int) (radius * mDirection.x), centerY + (int) (radius * mDirection.z));

        //
        // the raw dots don't need to be antialiased
        //
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int squareradius = (diameter * diameter >> 2) - 4;
        g.setPaint(POINT_COLOR);
        for (Vector3f mContact : mContacts) {
            float distX = mContact.x - mOrigin.x;
            float distY = mContact.z - mOrigin.z;
            double dist = Math.sqrt((double) (distX * distX + distY * distY));

            double log = (Math.log(dist) / LOG10) - 1.0;

            distX *= (1.0 / dist * log / (mMaxLog - 1) * radius);
            distY *= (1.0 / dist * log / (mMaxLog - 1) * radius);

            int x = (int) distX;
            int y = (int) distY;

            if ((x * x + y * y) < squareradius) {
                g.fillRect(x + centerX, y + centerY, 2, 2);
            }
        }

    }

    public void setOrigin(Vector3f position, double direction) {
        mOrigin.set(position);
        mDirection.x = (float) -Math.sin(direction);
        mDirection.z = (float) -Math.cos(direction);
        mDirection.y = 0;
    }

    public void setOrigin(Vector3f position, Vector3f direction) {
        mOrigin.set(position);
        mDirection.add(direction).normalize();
    }

    public void setContacts(Vector3f[] contacts) {
        mContacts = contacts;
    }